5d4212541b4d26d00258943766c74d0e
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var loadUtils = _interopDefault(require('loader-utils'));
var minimatch = _interopDefault(require('minimatch'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));

var getOptions = function (context) {
    return loadUtils.getOptions(context);
};

/**
 * validate
 *
 * takes an array of arrays of validations and
 * throws if an error occurs
 */
var validate = function (validations) {
    if (process.env.NODE_ENV !== 'production') {
        for (var _i = 0, validations_1 = validations; _i < validations_1.length; _i++) {
            var validation = validations_1[_i];
            var condition = validation[0];
            var errorMessage = validation[1];
            if (condition) {
                throw new Error(errorMessage);
            }
        }
    }
};

var isMatched = function (resourcePath, pattern) {
    if (!resourcePath || !pattern) {
        return false;
    }
    try {
        return minimatch(resourcePath, pattern, { dot: true }) || !!resourcePath.match(pattern);
    }
    catch (_a) {
        return false;
    }
};
/**
 * match include will return source
 * @param resourcePath
 * @param include
 */
var hasIncluded = function (resourcePath, include) {
    if (include === void 0) { include = []; }
    if (!resourcePath || !include) {
        return true;
    }
    return include.some(function (v) {
        return isMatched(resourcePath, v);
    });
};
/**
 * match exclude will return tpl
 * @param resourcePath
 * @param exclude
 */
var hasExcluded = function (resourcePath, exclude) {
    if (exclude === void 0) { exclude = []; }
    if (!resourcePath || !exclude) {
        return false;
    }
    return exclude.some(function (v) {
        return isMatched(resourcePath, v);
    });
};
var match = function (resourcePath, options) {
    if (!options || !resourcePath) {
        return false;
    }
    if (options.include) {
        return !hasIncluded(resourcePath, options.include);
    }
    if (options.exclude) {
        return hasExcluded(resourcePath, options.exclude);
    }
    return false;
};

var presetFactory = {
    create: function (preset) {
        return {
            name: preset.name,
            onInit: function () {
                preset.onInit && preset.onInit();
            },
            onMatch: function (resourcePath, options) {
                if (preset.onMatch) {
                    validate([[typeof preset.onMatch !== 'function', 'preset.onMatch should be function']]);
                    return preset.onMatch(resourcePath, options);
                }
                return match(resourcePath, options);
            },
            onReturn: function (source) {
                if (preset.onReturn) {
                    validate([[typeof preset.onReturn !== 'function', 'preset.onReturn should be function']]);
                    return preset.onReturn(source);
                }
                return source;
            },
        };
    },
};

var TEPLATES_PATH = path.resolve(__dirname, '../templates/');
var cached = {};
var loadTpl = function (tplName) {
    if (cached[tplName]) {
        return cached[tplName] || '';
    }
    var presetTpl = fs.readFileSync(path.resolve(TEPLATES_PATH, tplName + ".tpl")).toString();
    cached[tplName] = presetTpl;
    return presetTpl;
};

var tpl = '';
var ReactRoute = {
    name: 'react-route',
    onInit: function () {
        if (tpl) {
            return;
        }
        tpl = loadTpl('react-route');
    },
    onReturn: function (source) {
        return tpl || source;
    },
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var tpl$1 = '';
var defaultIncludes = [
    '**/layouts/**',
    '**/*/_layout?(.tsx|.jsx)',
    '**/index/**',
    '**/src/pages/*?(.tsx|.jsx|.ts|.js)',
    '**/src/*?(.tsx|.jsx|.ts|.js)',
    '**/NotFound?(.jsx|.tsx)',
    '**/src/pages/.umi/**',
    '**/src/!(pages)/**',
    '**/components/**',
    // tep add models
    '**/models/**',
];
var UmiRoute = {
    name: 'umi-route',
    onInit: function () {
        if (tpl$1) {
            return;
        }
        tpl$1 = loadTpl('react-route');
    },
    onMatch: function (resourcePath, options) {
        return match(resourcePath, __assign({}, options, { include: (options.include || []).concat(defaultIncludes) }));
    },
    onReturn: function (source) {
        return tpl$1 || source;
    },
};

var tpl$2 = '';
var defaultIncludes$1 = ['**/src/*?(.tsx|.jsx|.ts|.js)'];
var isRematchModel = function (resourcePath) {
    return minimatch(resourcePath, '**/models/**');
};
var UmiRematch = {
    name: 'umi-rematch',
    onInit: function () {
        if (tpl$2) {
            return;
        }
        tpl$2 = loadTpl('rematch');
    },
    onMatch: function (resourcePath, options) {
        if (!isRematchModel(resourcePath)) {
            return false;
        }
        return match(resourcePath, __assign({}, options, { include: (options.include || []).concat(defaultIncludes$1) }));
    },
    onReturn: function (source) {
        return tpl$2 || source;
    },
};

var utils = {
    match: match,
    loadTpl: loadTpl
};

var presets = {
    'react-route': presetFactory.create(ReactRoute),
    'umi-route': presetFactory.create(UmiRoute),
    'umi-rematch': presetFactory.create(UmiRematch),
};
var getPresets = function (options) {
    return options.presets
        ? options.presets.map(function (p) {
            var isStrPreset = typeof p === 'string';
            if (isStrPreset) {
                return presets[p];
            }
            // cached presets
            if (!presets[p.name]) {
                presets[p.name] = presetFactory.create(p);
            }
            return presets[p.name];
        })
        : [];
};
function loader(source) {
    // only work in development mode
    if (process.env.NODE_ENV === 'production') {
        return source;
    }
    var options = getOptions(this);
    if (!options.presets) {
        return source;
    }
    var allPresets = getPresets(options);
    var result = source;
    for (var i = 0; i < allPresets.length; i++) {
        var currentPreset = allPresets[i];
        if (currentPreset) {
            currentPreset.onInit();
            if (currentPreset.onMatch(this.resourcePath, options)) {
                result = currentPreset.onReturn(source);
                break;
            }
        }
    }
    return result;
}

exports.default = loader;
exports.getPresets = getPresets;
exports.utils = utils;
